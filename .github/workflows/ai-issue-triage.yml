name: AI Issue Triage

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to triage'
        required: true
        type: number

jobs:
  ai-triage:
    if: github.event_name == 'workflow_dispatch' || github.event.label.name == 'needs triage'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      models: read
      contents: read

    env:
      SUPPRESS_LABELS: 'false'
      SUPPRESS_COMMENTS: 'false'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build codebase context
        id: codebase
        shell: bash
        run: |
          # Extract key CLI facts from the actual codebase for AI context.
          # This ensures the AI answers based on real code, not guesses.
          CONTEXT="## Codebase Reference (auto-extracted from source)\n\n"
          CONTEXT+="**Important:** Only reference commands, flags, and features listed below. Do not invent or assume any CLI capability not documented here.\n\n"

          # â”€â”€ Commands & Flags (from parsers) â”€â”€
          CONTEXT+="### Filesystem Commands (fab_fs_parser.py)\n"
          CONTEXT+="| Command | Aliases | Key Flags |\n|---|---|---|\n"
          CONTEXT+="| ls | dir | \`path\` (opt), \`-l/--long\`, \`-a/--all\`, \`-q/--query\` |\n"
          CONTEXT+="| mkdir | create | \`path\` (req), \`-P/--params\` (key=value) |\n"
          CONTEXT+="| cd | â€” | \`path\` (req) |\n"
          CONTEXT+="| rm | del | \`path\` (req), \`-f/--force\` |\n"
          CONTEXT+="| mv | move | \`from_path\`, \`to_path\` (req), \`-f/--force\`, \`-r/--recursive\` |\n"
          CONTEXT+="| cp | copy | \`from_path\`, \`to_path\` (req), \`-f/--force\`, \`-r/--recursive\` |\n"
          CONTEXT+="| exists | â€” | \`path\` (req) |\n"
          CONTEXT+="| pwd | â€” | â€” |\n"
          CONTEXT+="| open | â€” | \`path\` (req) |\n"
          CONTEXT+="| export | â€” | \`path\` (req), \`-o/--output\` (req, output dir), \`-a/--all\`, \`--format\`, \`-f/--force\` |\n"
          CONTEXT+="| get | â€” | \`path\` (req), \`-q/--query\`, \`-o/--output\` (output file), \`-v/--verbose\`, \`-f/--force\` |\n"
          CONTEXT+="| import | â€” | \`path\` (req), \`-i/--input\` (req, input dir), \`--format\`, \`-f/--force\` |\n"
          CONTEXT+="| set | â€” | \`path\` (req), \`-q/--query\` (req), \`-i/--input\` (req), \`-f/--force\` |\n"
          CONTEXT+="| clear | cls | â€” |\n"
          CONTEXT+="| ln | mklink | \`path\` (req), \`--type\` (req: adlsGen2/amazonS3/dataverse/googleCloudStorage/oneLake/s3Compatible), \`--target\`, \`-i/--input\`, \`-f/--force\` |\n"
          CONTEXT+="| start | â€” | \`path\` (req), \`-f/--force\` |\n"
          CONTEXT+="| stop | â€” | \`path\` (req), \`-f/--force\` |\n"
          CONTEXT+="| assign | â€” | \`path\` (req), \`-W/--workspace\` (req), \`-f/--force\` |\n"
          CONTEXT+="| unassign | â€” | \`path\` (req), \`-W/--workspace\` (req), \`-f/--force\` |\n\n"

          CONTEXT+="### Auth Commands (fab auth ...)\n"
          CONTEXT+="| Command | Flags |\n|---|---|\n"
          CONTEXT+="| login | \`-u/--username\` (client ID), \`-p/--password\` (client secret), \`-t/--tenant\`, \`-I/--identity\` (managed identity), \`--certificate\` (PEM cert path), \`--federated-token\` |\n"
          CONTEXT+="| logout | â€” |\n"
          CONTEXT+="| status | â€” |\n\n"

          CONTEXT+="### Config Commands (fab config ...)\n"
          CONTEXT+="set \`key\` \`value\`, get \`key\`, ls, clear-cache\n\n"

          CONTEXT+="### Job Commands (fab jobs ...)\n"
          CONTEXT+="| Command | Key Flags |\n|---|---|\n"
          CONTEXT+="| start | \`path\`, \`-P/--params\`, \`-C/--config\`, \`-i/--input\` |\n"
          CONTEXT+="| run | \`path\`, \`-P/--params\`, \`--timeout\`, \`--polling_interval\` |\n"
          CONTEXT+="| run-list | \`path\`, \`--schedule\` |\n"
          CONTEXT+="| run-cancel | \`path\`, \`--id\` (req) |\n"
          CONTEXT+="| run-sch | \`path\`, \`--type\` (cron/daily/weekly), \`--interval\`, \`--start\`, \`--end\`, \`--days\` |\n"
          CONTEXT+="| run-status | \`path\`, \`--id\` (req) |\n\n"

          CONTEXT+="### ACL Commands (fab acl ...)\n"
          CONTEXT+="ls \`path\`, get \`path\`, set \`path\` \`-I/--identity\` \`-R/--role\` (Admin/Member/Contributor/Viewer/Owner), rm \`path\` \`-I/--identity\`\n\n"

          CONTEXT+="### API Command\n"
          CONTEXT+="fab api \`endpoint\` \`-X/--method\` (get/post/delete/put/patch) \`-A/--audience\` (fabric/storage/azure/powerbi) \`-i/--input\` \`-P/--params\` \`-H/--headers\`\n\n"

          CONTEXT+="### Table Commands (fab table ...)\n"
          CONTEXT+="schema \`path\`, load \`path\` \`--file\` \`--mode\` (append/overwrite), vacuum \`path\` \`--retain_n_hours\`, optimize \`path\` \`--vorder\` \`--zorder\`\n\n"

          # â”€â”€ Global Flags â”€â”€
          CONTEXT+="### Global Flags\n"
          CONTEXT+="\`--output_format\`: choices are \`json\` or \`text\` (default: \`text\`). There is NO \`--output\`, \`-o\`, or \`--format\` global flag.\n"
          CONTEXT+="Note: \`-o/--output\` on export/get is for output directory/file path, NOT output format.\n"
          CONTEXT+="\`-help\`: show help\n\n"

          # â”€â”€ Item Types (dynamically extracted) â”€â”€
          CONTEXT+="### Supported Item Types\n"
          ITEMS=$(grep -E '^\s+\w+ = "' src/fabric_cli/core/fab_types.py | sed 's/.*= "//;s/"//' | sort | tr '\n' ', ' | sed 's/,$//')
          CONTEXT+="$ITEMS\n\n"

          # â”€â”€ Hidden Entities â”€â”€
          CONTEXT+="### Hidden Entities (tenant-level, via \`-a\` flag or dot-prefix)\n"
          CONTEXT+=".capacities, .connections, .gateways, .domains\n\n"
          CONTEXT+="### Hidden Entities (workspace-level)\n"
          CONTEXT+=".sparkpools, .managedidentities, .managedprivateendpoints, .externaldatashares\n\n"

          # â”€â”€ Auth Methods & Env Vars â”€â”€
          CONTEXT+="### Authentication Methods\n"
          CONTEXT+="1. **Interactive browser**: \`fab auth login\` (default)\n"
          CONTEXT+="2. **Service principal (secret)**: \`fab auth login -u <client_id> -p <client_secret> -t <tenant_id>\`\n"
          CONTEXT+="   Or env vars: \`FAB_SPN_CLIENT_ID\` + \`FAB_SPN_CLIENT_SECRET\` + \`FAB_TENANT_ID\`\n"
          CONTEXT+="3. **Service principal (certificate)**: \`fab auth login -u <client_id> --certificate <path.pem> -t <tenant_id>\`\n"
          CONTEXT+="   Or env vars: \`FAB_SPN_CLIENT_ID\` + \`FAB_SPN_CERT_PATH\` (+ opt \`FAB_SPN_CERT_PASSWORD\`) + \`FAB_TENANT_ID\`\n"
          CONTEXT+="4. **Service principal (federated)**: \`fab auth login -u <client_id> --federated-token <token> -t <tenant_id>\`\n"
          CONTEXT+="   Or env var: \`FAB_SPN_FEDERATED_TOKEN\`\n"
          CONTEXT+="5. **Managed identity (system)**: \`fab auth login -I\`\n"
          CONTEXT+="6. **Managed identity (user-assigned)**: \`fab auth login -I -u <client_id>\`\n"
          CONTEXT+="7. **Direct access token**: \`FAB_TOKEN\` env var (no login needed)\n\n"

          # â”€â”€ Error Codes (dynamically extracted) â”€â”€
          CONTEXT+="### Error Codes\n"
          ERRORS=$(grep -E '^ERROR_' src/fabric_cli/core/fab_constant.py | sed 's/ = "/: /;s/"$//' | tr '\n' ', ' | sed 's/,$//')
          CONTEXT+="$ERRORS\n\n"

          # â”€â”€ Runnable & OneLake â”€â”€
          CONTEXT+="### Runnable Item Types (fab start / fab jobs run)\n"
          CONTEXT+="SparkJobDefinition (sparkjob), Notebook (RunNotebook), DataPipeline (Pipeline), Lakehouse (TableMaintenance)\n\n"

          CONTEXT+="### OneLake Item Types\n"
          CONTEXT+="Folder, File, Table, Shortcut\n\n"

          # â”€â”€ Shortcut Types (fab ln) â”€â”€
          CONTEXT+="### Shortcut Types (fab ln --type)\n"
          CONTEXT+="adlsGen2, amazonS3, dataverse, googleCloudStorage, oneLake, s3Compatible\n"

          echo -e "$CONTEXT" > /tmp/codebase-context.txt

          # Inject codebase context into prompt files as part of the system message.
          # This way the AI sees the context privately, not in the issue body or comment.
          mkdir -p /tmp/prompts
          python3 << 'PYEOF'
          import os, glob
          context = open('/tmp/codebase-context.txt').read()
          for prompt in glob.glob('.github/prompts/*.prompt.yml'):
              content = open(prompt).read()
              marker = '## Your Task'
              if marker in content:
                  content = content.replace(marker, context + '\n      ' + marker)
              out = '/tmp/prompts/' + os.path.basename(prompt)
              open(out, 'w').write(content)
          PYEOF

      - name: Resolve issue details
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue?.number || ${{ inputs.issue_number || 0 }};
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const { data: issue } = await github.rest.issues.get({
              owner, repo, issue_number: issueNumber,
            });

            // Detect re-triage: check if any ai: labels exist from a prior assessment
            const hasAiLabels = issue.labels.some(l => l.name.startsWith('ai:'));

            // Check for prior AI assessment comments
            const { data: comments } = await github.rest.issues.listComments({
              owner, repo, issue_number: issueNumber, per_page: 100,
            });
            const hasAiComment = comments.some(c =>
              c.body && c.body.includes('### AI Assessment:')
            );

            const isRetriage = hasAiLabels || hasAiComment;
            let issueBody = issue.body || '';

            if (isRetriage) {
              // Find the last AI comment index
              const lastAiIdx = comments.reduce((acc, c, i) =>
                c.body && c.body.includes('### AI Assessment:') ? i : acc, -1);

              // Collect author replies after the last AI comment
              const authorReplies = comments
                .slice(lastAiIdx + 1)
                .filter(c => c.user.login === issue.user.login)
                .map(c => c.body)
                .join('\n\n---\n\n');

              if (authorReplies) {
                issueBody = `[RE-TRIAGE] The author has provided additional information in response to a prior AI assessment.\n\n`
                  + `## Original Issue Summary\n${issue.title}\n\n`
                  + `## Author's Follow-up Response\n${authorReplies}\n\n`
                  + `Focus your assessment on the new information provided above. Reference the original issue only if needed for context.`;
              }
            }

            core.setOutput('number', issue.number);
            core.setOutput('body', issueBody);
            core.setOutput('title', issue.title);
            core.setOutput('html_url', issue.html_url);
            core.setOutput('labels', issue.labels.map(l => l.name).join(','));
            core.setOutput('is_retriage', isRetriage.toString());

      - name: Run AI assessment
        id: ai-assessment
        uses: github/ai-assessment-comment-labeler@v1.0.1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue_number: ${{ steps.issue.outputs.number }}
          issue_body: ${{ steps.issue.outputs.body }}
          repo_name: ${{ github.event.repository.name || github.repository }}
          owner: ${{ github.repository_owner }}
          ai_review_label: 'needs triage'
          prompts_directory: '/tmp/prompts'
          labels_to_prompts_mapping: 'bug,bug-triage.prompt.yml|enhancement,feature-triage.prompt.yml|question,question-triage.prompt.yml'
          model: 'openai/gpt-4.1'
          max_tokens: 1500
          # -------------------------------------------------------
          # Phase control â€” toggle these two flags to switch phases:
          #   Phase 1 & 2 (fork):  false / false
          #   Phase 3 (main):      true  / true
          #   Phase 4 (main):      false / false
          # -------------------------------------------------------
          suppress_comments: ${{ env.SUPPRESS_COMMENTS }}
          suppress_labels: ${{ env.SUPPRESS_LABELS }}

      - name: Post-process triage results
        if: steps.ai-assessment.outputs.ai_assessments != ''
        uses: actions/github-script@v7
        env:
          ASSESSMENT_OUTPUT: ${{ steps.ai-assessment.outputs.ai_assessments }}
          SUPPRESS_LABELS: ${{ env.SUPPRESS_LABELS }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const assessments = JSON.parse(process.env.ASSESSMENT_OUTPUT);
            const issueNumber = parseInt(process.env.ISSUE_NUMBER);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const suppressLabels = process.env.SUPPRESS_LABELS === 'true';

            let needsHumanReview = false;
            let addHelpWanted = false;
            let needsAuthorFeedback = false;
            let canAutoClose = false;

            for (const assessment of assessments) {
              const label = (assessment.assessmentLabel || '').toLowerCase();

              // Check if the assessment requires human review
              if (label.includes('needs team review') || label.includes('needs maintainer input') || label.includes('potential bug')) {
                needsHumanReview = true;
              }

              // Check if feature should be tagged as help wanted
              if (label.includes('help wanted')) {
                addHelpWanted = true;
              }

              // Check if more information is needed from the issue author
              if (label.includes('needs author feedback') || label.includes('requires additional details')) {
                needsAuthorFeedback = true;
              }

              // Check if the AI fully resolved the issue (answered question, explained misconfiguration, redirected to docs)
              if (label.includes('answered') || label.includes('likely misconfiguration') || label.includes('redirect to docs')) {
                canAutoClose = true;
              }

              // Log for job summary
              core.info(`Prompt: ${assessment.prompt}, Label: ${assessment.assessmentLabel}`);
            }

            // Skip label changes in summary-only mode (Phase 3)
            if (suppressLabels) {
              core.info('Labels suppressed (summary-only mode) â€” skipping post-process label changes.');
              return;
            }

            // Add 'help wanted' label if AI recommended community contribution
            if (addHelpWanted) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issueNumber,
                labels: ['help wanted']
              });
              core.info('Added "help wanted" label based on AI assessment.');
            }

            // If AI fully handled the issue, remove 'needs triage' so the team isn't notified
            if (!needsHumanReview) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  name: 'needs triage'
                });
                core.info('Removed "needs triage" â€” AI handled this issue.');
              } catch (e) {
                // Label may have already been removed by the action
                core.info(`Could not remove "needs triage" label: ${e.message}`);
              }

              // Auto-close if AI fully resolved (answered, misconfiguration, redirected)
              if (canAutoClose && !needsAuthorFeedback && !addHelpWanted) {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  state: 'closed',
                  state_reason: 'completed'
                });
                core.info('Auto-closed issue â€” AI fully resolved it.');
              }
            } else {
              // Add consolidated label for easy filtering of all issues needing team attention
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issueNumber,
                labels: ['ai:needs team attention']
              });

              // Notify team via comment on escalated issues
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: 'ðŸ”” @microsoft/fabric-cli-dev â€” This issue has been flagged by AI triage as requiring team attention. Please review the assessment above.'
              });
              core.info('Keeping "needs triage" and notified team.');
            }

      - name: Generate triage summary
        if: always() && steps.ai-assessment.outputs.ai_assessments != ''
        uses: actions/github-script@v7
        env:
          ASSESSMENT_OUTPUT: ${{ steps.ai-assessment.outputs.ai_assessments }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.number }}
          ISSUE_TITLE: ${{ steps.issue.outputs.title }}
          ISSUE_URL: ${{ steps.issue.outputs.html_url }}
        with:
          script: |
            const assessments = JSON.parse(process.env.ASSESSMENT_OUTPUT);
            const issueNumber = process.env.ISSUE_NUMBER;
            const issueTitle = process.env.ISSUE_TITLE;
            const issueUrl = process.env.ISSUE_URL;

            let summary = `## ðŸ¤– AI Triage Report\n\n`;
            summary += `**Issue:** [#${issueNumber} â€” ${issueTitle}](${issueUrl})\n\n`;

            for (const assessment of assessments) {
              summary += `### Prompt: \`${assessment.prompt}\`\n`;
              summary += `**Assessment Label:** \`${assessment.assessmentLabel}\`\n\n`;
              summary += `<details><summary>Full AI Response</summary>\n\n`;
              summary += `${assessment.response}\n\n`;
              summary += `</details>\n\n---\n\n`;
            }

            // Write to job summary
            core.summary.addRaw(summary);
            await core.summary.write();

            // Also write to file for artifact upload
            const fs = require('fs');
            fs.mkdirSync('triage-reports', { recursive: true });
            fs.writeFileSync(
              `triage-reports/issue-${issueNumber}-triage.md`,
              summary
            );

      - name: Upload triage report
        if: always() && steps.ai-assessment.outputs.ai_assessments != ''
        uses: actions/upload-artifact@v4
        with:
          name: triage-report-issue-${{ steps.issue.outputs.number }}
          path: triage-reports/
          retention-days: 30
